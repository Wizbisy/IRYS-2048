<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IRYS 2048 - Game</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    #game-container {
      position: relative;
    }
    #game-grid div {
      position: relative;
    }
    .tile {
      transition: all 0.2s ease-in-out;
    }
    .game-over {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.75);
      z-index: 10;
    }
    .button-disabled {
      opacity: 0.5;
      pointer-events: none;
    }
  </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center justify-center p-4">
  <img src="/logo.png" alt="IRYS 2048 Logo" width="200" height="50" class="mb-8" />
  <div id="game-container" class="relative w-full max-w-md aspect-square bg-gray-800 rounded-2xl p-4 shadow-lg">
    <div id="score" class="absolute top-4 left-4 text-white text-lg font-bold">
      Score: <span id="score-value">0</span>
    </div>
    <a href="/leaderboard" class="absolute top-4 right-4 text-white underline text-lg hover:text-gray-300">Leaderboard</a>
    <div id="game-grid" class="grid grid-cols-4 gap-2 w-full h-full"></div>
  </div>
  <img src="/sprite.png" alt="Sprite" width="100" height="100" class="absolute bottom-0 left-0" />
  <img src="/sprite.png" alt="Sprite" width="100" height="100" class="absolute bottom-0 right-0 scale-x-[-1]" />

  <script>
    const GRID_SIZE = 4;
    let tiles = [];
    let score = 0;
    let gameOver = false;

    function initializeBoard() {
      tiles = [];
      score = 0;
      gameOver = false;
      document.getElementById('score-value').textContent = score;
      for (let i = 0; i < 2; i++) addRandomTile();
      updateGrid();
    }

    function addRandomTile() {
      const available = [];
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (!tiles.some(t => t.x === x && t.y === y)) available.push({ x, y });
        }
      }
      if (available.length > 0) {
        const { x, y } = available[Math.floor(Math.random() * available.length)];
        tiles.push({ id: Date.now() + Math.random(), value: Math.random() < 0.9 ? 2 : 4, x, y });
        updateGrid();
      }
    }

    function updateGrid() {
      const grid = document.getElementById('game-grid');
      grid.innerHTML = '';
      for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        const div = document.createElement('div');
        div.className = 'bg-gray-700 rounded-lg';
        div.style.aspectRatio = '1 / 1';
        grid.appendChild(div);
      }
      tiles.forEach(tile => {
        const div = document.createElement('div');
        div.textContent = tile.value;
        div.className = `tile absolute bg-gray-600 rounded-lg flex items-center justify-center text-white text-2xl font-bold ${tile.value >= 1024 ? 'text-yellow-300' : ''}`;
        div.style.width = `${100 / GRID_SIZE}%`;
        div.style.height = `${100 / GRID_SIZE}%`;
        div.style.left = `${(tile.x * 100) / GRID_SIZE}%`;
        div.style.top = `${(tile.y * 100) / GRID_SIZE}%`;
        grid.appendChild(div);
      });
    }

    function moveTiles(direction) {
      if (gameOver) return;
      let moved = false;
      let newScore = score;
      const newTiles = [...tiles];
      const sortedTiles = [...tiles].sort((a, b) => {
        if (direction === 'up') return a.y - b.y;
        if (direction === 'down') return b.y - a.y;
        if (direction === 'left') return a.x - b.x;
        return b.x - a.x;
      });

      const merged = [];
      for (let i = 0; i < GRID_SIZE; i++) {
        let line = [];
        if (direction === 'up' || direction === 'down') {
          line = sortedTiles.filter(t => t.x === i);
          if (direction === 'down') line.reverse();
        } else {
          line = sortedTiles.filter(t => t.y === i);
          if (direction === 'right') line.reverse();
        }

        let newLine = [];
        let pos = 0;
        for (let j = 0; j < line.length; j++) {
          if (j < line.length - 1 && line[j].value === line[j + 1].value && !merged.includes(line[j].id) && !merged.includes(line[j + 1].id)) {
            const newValue = line[j].value * 2;
            newLine.push({ ...line[j], value: newValue, x: direction === 'up' || direction === 'down' ? i : pos, y: direction === 'left' || direction === 'right' ? i : pos });
            merged.push(line[j].id, line[j + 1].id);
            newScore += newValue;
            j++;
            pos++;
            moved = true;
          } else {
            newLine.push({ ...line[j], x: direction === 'up' || direction === 'down' ? i : pos, y: direction === 'left' || direction === 'right' ? i : pos });
            pos++;
          }
        }
        newLine.forEach(t => {
          const index = newTiles.findIndex(tt => tt.id === t.id);
          if (index !== -1) newTiles[index] = t;
        });
      }

      if (moved) {
        tiles = [...newTiles, addRandomTile()];
        score = newScore;
        document.getElementById('score-value').textContent = score;
        if (!canMove()) {
          gameOver = true;
          showGameOver();
        }
      }
    }

    function canMove() {
      if (tiles.length < GRID_SIZE * GRID_SIZE) return true;
      for (const tile of tiles) {
        const neighbors = [{ x: tile.x + 1, y: tile.y }, { x: tile.x - 1, y: tile.y }, { x: tile.x, y: tile.y + 1 }, { x: tile.x, y: tile.y - 1 }];
        for (const { x, y } of neighbors) {
          if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
            const neighbor = tiles.find(t => t.x === x && t.y === y);
            if (!neighbor || neighbor.value === tile.value) return true;
          }
        }
      }
      return false;
    }

    function showGameOver() {
      const gameOverDiv = document.createElement('div');
      gameOverDiv.className = 'game-over flex items-center justify-center';
      gameOverDiv.innerHTML = `
        <div class='flex flex-col items-center gap-4 bg-gray-800 p-6 rounded-2xl shadow-lg'>
          <h2 class='text-2xl font-bold'>Game Over!</h2>
          <p class='text-xl'>Score: ${score}</p>
          <button id="upload-score" class='bg-purple-600 text-white px-6 py-3 rounded-2xl shadow-lg hover:bg-purple-700 transition-colors ${!window.ethereum ? 'button-disabled' : ''}'>
            Upload Score
          </button>
          <button id="new-game" class='bg-gray-600 text-white px-6 py-3 rounded-2xl shadow-lg hover:bg-gray-700 transition-colors'>
            New Game
          </button>
        </div>
      `;
      document.body.appendChild(gameOverDiv);
      document.getElementById('upload-score').addEventListener('click', uploadScore);
      document.getElementById('new-game').addEventListener('click', () => {
        document.body.removeChild(gameOverDiv);
        gameOver = false;
        initializeBoard();
      });
    }

    async function uploadScore() {
      if (!window.wagmiConfig || !window.ethereum) {
        alert('Please install MetaMask and refresh to connect your wallet.');
        return;
      }
      try {
        const provider = await window.ethereum.request({ method: 'eth_requestAccounts' });
        const { WebUploader, WebEthereum } = window;
        const uploader = await new WebUploader(WebEthereum).withProvider(provider);
        await uploader.upload(JSON.stringify({ address: provider[0], score, timestamp: Date.now() }), {
          tags: [{ name: "App", value: "IRYS-2048" }, { name: "Type", value: "Score" }],
          url: 'https://testnet-rpc.irys.xyz'
        });
        alert('Score uploaded successfully!');
      } catch (error) {
        alert('Failed to upload score: ' + error.message);
        console.error(error);
      }
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp') moveTiles('up');
      else if (e.key === 'ArrowDown') moveTiles('down');
      else if (e.key === 'ArrowLeft') moveTiles('left');
      else if (e.key === 'ArrowRight') moveTiles('right');
    });

    initializeBoard();
  </script>
  <script type="module" src="/providers.js"></script>
  <script type="module">
    import { WebUploader } from 'https://unpkg.com/@irys/web-upload@0.0.2/dist/index.js';
    import { WebEthereum } from 'https://unpkg.com/@irys/web-upload-ethereum@0.0.2/dist/index.js';
    window.WebUploader = WebUploader;
    window.WebEthereum = WebEthereum;
  </script>
</body>
</html>
